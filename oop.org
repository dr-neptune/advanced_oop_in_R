* Advanced Object-Oriented Programming in R

** Chapter 1 | Classes and Generic Functions 

In R, data is immutable, so you don't write code where you change the state of an object. Instead you work with objects as values, and operations on objects create new objects when you need a new "state". 

*** Generic Functions 

The term generic functions refers to functions that can be used on more than one data type. Since R is dynamically typed, this means that there is no check of type consistency before you run your programs. Type checking is really only a question of whether you can manipulate data in the way that your functions attempt to. This is also called "duck typing". Generic functions are also known as polymorphic functions. 

If we consider something, say a stack, by the operations defined on it, it is an abstract data type: 

- get the top element
- pop the first element off a stack
- push a new element to the top of a stack
- create an empty stack
- check if a stack is empty 

These operations are what a stack "is", but we can implement a stack in many different ways. To implement a stack, we need a concrete implementation. 

In general, in statically typed function languages you would define a signature for a stack - the functions and their type for the five operations - while in an object-oriented language you would define an abstract superclass. 

In R we would define the five operations as generic functions without any implementation, with the exception of creating an empty stack which must have a concrete implementation. Defining a generic function is done using the UseMethod function 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
top <- function(stack) UseMethod("top")
pop <- function(stack) UseMethod("pop")
push <- function(stack, element) UseMethod("push")
is_empty <- function(stack) UseMethod("is_empty")
#+END_SRC

UseMethod does a dispatch to different concrete implementations of functions in the S3 oop syste. When it is called, it will look for an implementation of a function and call it with the parameters that the generic function was called with. 

When defining generic methods, we can also specify a default function as well. These are called when UseMethod can not find a concrete implementation. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
top.default <- function(stack) .NotYetImplemented()
pop.default <- function(stack) .NotYetImplemented()
push.default <- function(stack, element) .NotYetImplemented()
is_empty.default <- function(stack) .NotYetImplemented()
#+END_SRC

*** Classes 

To make concrete implementations of abstract data types, we need to use classes. In the S3 system, you create a class, and assign a class to an object, just by setting an attribute on the object. The name of the class is all that defines it, so there is no real type checking involved. 

We can make a concrete implementation of stack using a vector. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
empty_vector_stack <- function() {
    stack <- vector("numeric")
    class(stack) <- "vector_stack"
    stack
}

(stack <- empty_vector_stack())
attributes(stack)
class(stack)

# implement the operations for vector stack
top.vector_stack <- function(stack) stack[1]

pop.vector_stack <- function(stack) {
    new_stack <- stack[-1]
    cat("Popping stack value: ", stack[1], "\nNew stack: ", new_stack, "\n")
    class(new_stack) <- "vector_stack"
    new_stack
}

push.vector_stack <- function(element, stack) {
    new_stack <- c(element, stack)
    class(new_stack) <- "vector_stack"
    new_stack
}

is_empty.vector_stack <- function(stack) length(stack) == 0
#+END_SRC

The names of functions are composed of two parts: before the period "." we have names of the generic functions that define a stack, and after the period we have the class name. This name format has semantic meaning; it is how generic functions figure out which concrete functions should be called based on the data provided to them. 

When the generic functions call UseMethod, this function will check if the first value with which the generic function was called has an associated class. If so, it will get the name of that class and see if it can find a function with the name of the generic function (the name param given to UseMethod, not necessarily the name of the function that calls UseMethod) before a period and the name of the class after a period. If so, it calls that function, otherwise it calls the .default if it exists. 

This lookup mechanism gives semantic meaning to function names, and you shouldn't use periods in function names unless you want R to interpret them this way. 

In some of our functions above, we explicitly set the class of the concatenated new vector. This way, we make sure that we return a stack. By explicitly setting the class, we make sure that the function returns a stack that we can use with the generic functions again. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
# test out our concrete implementation 
library(magrittr)

(stack %<>%
    push(1) %>% 
    push(2) %>%
    push(3) %>%
    push(4) %>%
    push(5))

while (!is_empty(stack)) stack <- pop(stack)
#+END_SRC

We can avoid having to set the class attribute explicitly whenever we update it (whenever we return a new value) by wrapping the class creation code in another function. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
make_vector_stack <- function(elements) {
    structure(elements, class = "vector_stack")
}

empty_vector_stack <- function() {
    make_vector_stack(vector("numeric"))
}

top.vector_stack <- function(stack) stack[1]

pop.vector_stack <- function(stack) {
    new_stack <- make_vector_stack(stack[-1])
    cat("Popping stack value: ", stack[1], "\nNew stack: ", new_stack, "\n")
    new_stack
}

push.vector_stack <- function(stack, element) {
    new_stack <- make_vector_stack(c(element, stack))
    cat("Pushing stack value: ", element, "\nNew stack: ", new_stack, "\n")
    new_stack
}

is_empty.vector_stack <- function(stack) length(stack) == 0
#+END_SRC

We are still setting the class attribute, we are just doing so implicitly by translating a vector into a stack using make_vector_stack. That function uses the structure function to set the class attribute, but otherwise just represents the stack as a vector just like before. 

*** Polymorphism in Action 

The point of having generic functions is that we can have different implementations of the abstract operations. 

Using the vector implementation of a stack is problematic because each time we return a modified stack if creates a new vector, copying all of the elements over. This leads to a linear time complexity. Using a linked list, we can make them constant time operations. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
make_list_node <- function(head, tail) {
    list(head = head,
         tail = tail)
}

make_list_stack <- function(elements) {
    structure(list(elements = elements),
              class = "list_stack")
}

empty_list_stack <- function() make_list_stack(NULL)

top.list_stack <- function(stack) stack$elements$head

pop.list_stack <- function(stack) {
    cat(paste0("Popping stack value: ", stack$elements$head, "\n"))
    make_list_stack(stack$elements$tail)
}

push.list_stack <- function(stack, element) {
    cat(paste0("Pushing stack value: ", element, "\n"))
    make_list_stack(make_list_node(element, stack$elements))
}

is_empty.list_stack <- function(stack) is.null(stack$elements)
#+END_SRC 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
(empty_list_stack() %>%
    push(1) %>%
    push(2) %>%
    push(3) -> stack)
#+END_SRC

We now have two stack implementations. The point of having generic functions is that it doesn't matter which implementation we use, as long as it is only accessing the stack through the generic interface. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
stack_reverse <- function(empty, elements) {
    stack <- empty
    
    for (element in elements) stack <- push(stack, element)

    result <- vector(class(top(stack)),
                     length(elements))

    for (i in seq_along(result)) {
        result[i] <- top(stack)
        stack <- pop(stack)
    }    

    result
}

stack_reverse(empty_vector_stack(), 1:5)
stack_reverse(empty_list_stack(), 1:5)
#+END_SRC

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
# benchmarking
library(microbenchmark)

microbenchmark(stack_reverse(empty_vector_stack(), 1:10000),
               stack_reverse(empty_list_stack(), 1:10000))
#+END_SRC

*** Designing Interfaces 

Any function that manipulates data only through generic functions is also polymorphic. To get the most out of polymorphism, you want to design your functions to be as polymorphic as possible: 

1. Don't refer to concrete implementations unless you really have to 
2. Any time you do refer to implementation details of a concrete type, do so through a generic function 

The reversal function is polymorphic because it doesn't refer to any concrete implementation. The choice of which concrete data structure is determined by the parameter, and the operations it performs on the stack all go through generic functions. 

More often, you will want to access the details of a concrete implementation. Suppose we wish to pop elements until we see a specific one, but only if that element is on the stack. If we are used to the vector representation, we might write: 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
pop_until <- function(stack, element) {
    if (element %in% stack) {
        while (top(stack) != element) stack <- pop(stack)
    }
    stack
}

vector_stack <- empty_vector_stack() %>%
    push(1) %>%
    push(2) %>%
    push(3) %T>% print  

pop_until(vector_stack, 1)

pop_until(vector_stack, 5)

pop_until(vector_stack, 2)
#+END_SRC

This function would not work in a list, as %in% does not support lists. It will always just return false 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
list_stack <- empty_list_stack() %>%
    push(1) %>%
    push(2) %>%
    push(3)

pop_until(list_stack, 1)
#+END_SRC

If you write an algorithm that operates on a polymorphic object, stick to the interface it has, if at all possible. For the pop_until function, we can implement it using the stack interface. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
pop_until <- function(stack, element) {
    s <- stack
    while (!is_empty(s) && top(s) != element) s <- pop(s)
    if (is_empty(s)) stack else s
}
#+END_SRC

If you can not achieve what you need using the interface, you should instead extend it. You can always write new generic functions that work on a class. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
contains <- function(stack, element) UseMethod("contains")

contains.default <- function(stack, element) .NotYetImplemented()

contains.vector_stack <- function(stack, element) element %in% stack
#+END_SRC

*** The Usefulness of Polymorphism 

Very eye opening section, worth looking into ;) 

*** Polymorphism and Algorithmic Programming 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
# implementation of mergesort on lists 
merge_lists <- function(x, y) {
    if (length(x) == 0) return(y)
    if (length(y) == 0) return(x)

    if (x[[1]] < y[[1]]) {
        c(x[1], merge_lists(x[-1], y))
    } else {
        c(y[1], merge_lists(x, y[-1]))
    }
}

sort_list <- function(x) {
    if (length(x <= 1)) return(x)
    start <- 1; end <- length(x); middle <- end %/% 2

    merge_lists(sort_list(x[start:middle],
                          x[(middle + 1):end]))
}
#+END_SRC

This works, but is quadratic in run time since it copies lists when it subscripts like x[-1], y[-1]. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
merge_lists <- function(x, y) {
    if (length(x) == 0) return(y)
    if (length(y) == 0) return(x)
    i <- j <- k <- 1
    result <- vector("list", length = n)

    while (i <= length(x) && j <= length(y)) {
        if (x[[i]] < y[[j]]) {
            result[[k]] <- y[[j]]
            j <- j + 1
        }
        k <- k + 1
    }

    if (i > length(x)) {
        result[k:n] <- y[j:length(y)]
    } else {
        result[k:n] <- x[i:length(x)]
    }
    result
}
#+END_SRC

With this implementation, we can sort lists of elements where "<" can be used to determine if one element is less than another. This doesn't necessarily work on our own classes. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
make_tuple <- function(x, y) {
    result <- c(x, y)
    class(result) <- "tuple"
    result 
}

x <- list(make_tuple(1, 2),
          make_tuple(1, 1),
          make_tuple(2, 0))

sort_list(x)
#+END_SRC

There are several ways we could fix this. We could define a generic function for comparison (call it "less") and then use that in the merge function 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
less <- function(x, y) UseMethod("less")
less.numeric <- function(x, y) x < y
less.typle <- function(x, y) x[1] < y[1] || x[2] < y[2]

merge_lists <- function(x, y) {
    if (length(x) == 0) return(y)
    if (length(y) == 0) return(x)
    i <- j <- k <- 1
    result <- vector("list", length = n)

    while (i <= length(x) && j <= length(y)) {
        if (less(x[[i]], y[[j]])) {
            result[[k]] <- y[[j]]
            j <- j + 1
        }
        k <- k + 1
    }

    if (i > length(x)) {
        result[k:n] <- y[j:length(y)]
    } else {
        result[k:n] <- x[i:length(x)]
    }
    result
}

sort_list(x)
#+END_SRC

The problem is that we would need to define concrete implementations of less for all types we wish to sort. Alternatively, we can tell R how to handle "<" for our own types, and we will see how in a later chapter. 

A third option is to make less a parameter of our sorting function 

*** More on UseMethod 

The UseMethod function is what we use to define a generic function, and it takes care of finding the appropriate concrete implementation using the name lookup we saw earlier. 

You can pass local variables along to concrete implementations if you assign them before you call UseMethod 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
foo <- function(object) UseMethod("foo")

foo.numeric <- function(object) object

foo(4)

bar <- function(object) {
    x <- 2
    UseMethod("bar")
}

bar.numeric <- function(object) x + object

bar(4)

# UseMethod doesn't behave like a normal function
baz <- function(object) UseMethod("baz") + 2 + stop("Wow!")
baz.numeric <- function(object) object
baz(4)
#+END_SRC

When UseMethod is invoked, the concrete function takes over completely, and the call to UseMethod never returns. Anything after it is not evaluated. 

** Chapter 2 | Class Hierarchies

Interfaces describe which generic functions objects of a given class must implement, and hierarchies chain together interfaces in "more-abstract / more-refined" relationships based on these functions.

*** Interfaces and Implementations 

We can think of the interface of a class as the kinds of operations, or methods, which we can apply to objects of the class. 
At the abstract level, we can describe the interface of a function by its formal arguments and its semantics. This can give us abstract functions. With that definition, we can say that an abstract data type is defined by a set of abstract functions. If we call a set of abstract functions an interface, then an abstract datatype is defined by an interface. 

*** Abstract and Concrete Classes 

A class encapsulates both what can be done with objects -- the interface that you have for them -- and how it is done -- how the interface is implemented. 

*** Example : Graphical Objects 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
# superclass methods 
draw <- function(object) UseMethod("draw")
bounding_box <- function(object) UseMethod("bounding_box")

# draw methods
draw.point <- function(object) {
    points(object["x"], object["y"])
}

draw.rectangle <- function(object) {
    rect(object["x1"],
         object["y1"],
         object["x2"],
         object["y2"])
}

draw.circle <- function(object) {
    plotrix::draw.circle(object["x"],
                         object["y"],
                         object["r"])
}

draw.composite <- function(object) {
    invisible(Map(draw, object))
}

# constructors for concrete classes 
point <- function(x, y) {
    object <- c(x, y)
    class(object) <- "point"
    names(object) <- c("x", "y")
    object
}

rectangle <- function(x1, y1, x2, y2) {
    object <- c(x1, y1, x2, y2)
    class(object) <- "rectangle"
    names(object) <- c("x1", "y1", "x2", "y2")
    object
}

circle <- function(x, y, r) {
    object <- c(x, y, r)
    class(object) <- "circle"
    names(object) <- c("x", "y", "r")
    object
}

composite <- function(...) {
    object <- list(...)
    class(object) <- "composite"
    object
}
#+END_SRC

Let's try it out 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
corners <- composite(point(2.5, 2.5),
                     point(2.5, 7.5),
                     point(7.5, 2.5),
                     point(7.5, 7.5))

plot(c(0, 10), c(0, 10), type = "n", axes = FALSE, xlab = "", ylab = "")
draw(point(5, 5))
draw(rectangle(2.5, 2.5, 7.5, 7.5))
draw(circle(5, 5, 4))
draw(corners)
#+END_SRC

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
# we can implement different methods like this
bounding_box.point <- function(object) {
    c(object["x"],
      object["y"],
      object["x"],
      object["y"])
}

bounding_box.rectangle <- function(object) {
    c(object["x1"],
      object["y1"],
      object["x2"],
      object["y2"])
}

bounding_box.circle <- function(object) {
    c(object["x"] - object["r"],
      object["y"] - object["r"],
      object["x"] + object["r"],
      object["y"] + object["r"])
}

bounding_box.composite <- function(object) {
    if (length(object) == 0) return(c(NA, NA, NA, NA))

    bb <- bounding_box(object[[1]])
    x1 <- bb[1]; y1 <- bb[2]; x2 <- bb[3]; y2 <- bb[4]

    for (element in object) {
        bb <- bounding_box(element)
        x1 <- min(x1, bb[1])
        y1 <- min(y1, bb[2])
        x2 <- max(x2, bb[3])
        y2 <- max(y2, bb[4])
    }
    
    c(x1, y1, x2, y2)
}
#+END_SRC

With that, we can collect all the graphical elements we wish to plot in a composite object and calculate the bounding box before we plot 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
all <- composite(point(5, 5),
                 rectangle(2.5, 2.5, 7.5, 7.5),
                 circle(5, 5, 4),
                 composite(point(2.5, 2.5),
                           point(2.5, 7.5),
                           point(7.5, 2.5),
                           point(7.5, 7.5)))

bb <- bounding_box(all)

plot(c(bb[1], bb[3]),
     c(bb[2], bb[4]),
     type = "n", axes = FALSE, xlab = "", ylab = "")
draw(all)
#+END_SRC

*** Publication Example 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
# publication interface
publication <- function(name, authors, citations) {
    structure(list(name = name,
                   authors = authors,
                   citations = citations),
              class = "publication")
}

name <- function(pub) pub$name
authors <- function(pub) pub$authors

articles <- function(name, authors, citations, journal, pages) {
    structure(list(name = name,
                   authors = authors,
                   citations = citations,
                   journal = journal,
                   pages = pages),
              class = c("article", "publication"))
}

journal <- function(pub) pub$journal
pages <- function(pub) pub$pages

book <- function(name, authors, citations, publisher, ISBN) {
    structure(list(name = name,
                   authors = authors,
                   citations = citations,
                   publisher = publisher,
                   ISBN = ISBN),
              class = c("book", "publication"))
}

publisher <- function(pub) pub$publisher
ISBN <- function(pub) pub$ISBN

# format publications for lists and so on. 
# instead of changing older code, utilize generic functions for formatting citations and specialize it for subclasses
format <- function(publ) UseMethod("format")

format.article <- function(publ) {
    paste(name(publ),
          authors(publ),
          journal(publ),
          pages(publ),
          sep = ", ")
}

format.book <- function(publ) {
    paste(name(publ),
          authors(publ),
          publisher(publ),
          ISBN(publ),
          sep = ", ")
}

print.publication <- function(x, ...) print(format(x))
#+END_SRC
** Chapter 3 | Implementation Reuse 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
A <- function() {
    structure(list(), class = "A")
}

B <- function() {
    structure(list(), class = c("B", "A"))
}

C <- function() {
    structure(list(), class = c("C", "B", "A"))
}

# create instances
x <- A(); y <- B(); z <- C()
list(x, y, z) %>% walk(class)

# create a generic function with only a default implementation
f <- function(x) UseMethod("f")
f.default <- function(x) print("f.default")

list(x, y, z) %>% walk(f)

g <- function(x) UseMethod("g")
g.default <- function(x) print("g.default")
g.A <- function(x) print("g.A")

list(x, y, z) %>% walk(g)

h <- function(x) UseMethod("h")
h.default <- function(x) print("h.default")
h.A <- function(x) print("h.A")
h.B <- function(x) print("h.B")

list(x, y, z) %>% walk(h)
#+END_SRC

*** Getting the Hierarchy Correct in the Constructors 

Instead of explicitly naming the superclass, we could manually call the constructor of the superclass, obtain an object, and then prepend the new class name to its class list

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
A <- function() {
    structure(list(),
              class = "A")
}

B <- function() {
    this <- A()
    class(this) <- c("B", class(this))
    this
}

C <- function() {
    this <- B()
    class(this) <- c("C", class(this))
    this
}
#+END_SRC

*** NextMethod 

When we specialize generic functions, we do not always need to implement everything from scratch; sometimes we can reuse implementations from more abstract classes and tweak the results a little. 

The NextMethod function lets you call inherited functions in a way that resembles UseMethod, and that uses it class sequence. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
format.publication <- function(publ) {
    paste(name(publ),
          authors(publ),
          sep = ", ")
}

format.article <- function(publ) {
    paste(NextMethod(),
          journal(publ),
          pages(publ),
          sep = ", ")
}

format.book <- function(publ) {
    paste(NextMethod(),
          publisher(publ),
          ISBN(publ),
          sep = ", ")
}
#+END_SRC

When we cann NextMethod, R will search through the class sequence for a class that implements the generic function we are currently evaluating. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
f.A <- function(x) {
    print("f.A")
    NextMethod()
}

f.B <- function(x) {
    print("f.B")
    NextMethod()
}

f.C <- function(x) {
    print("f.C")
    NextMethod()
}

list(x, y, z) %>% walk(f)
#+END_SRC

If we implement another function, where we only implement version for classes A and C but not for B. We will see the C objects evaluating the C version, then the A version since there is no B version. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
j <- function(x) UseMethod("j")
j.default <- function(x) print("j.default")
j.A <- function(x) {
    print("j.A")
    NextMethod()
}

j.C <- function(x) {
    print("j.C")
    NextMethod()
}

list(x, y, z) %>% walk(j)
#+END_SRC

** Chapter 4 | Statistical Models 

*** Bayesian Linear Regression 

We will assume that the prior distribution of w is a normal distribution with mean zero and independent components, so a diagonal covariance matrix. This means that, on average, we believe the line we are fitting to be flat and going through the plane origin, but how strongly we believe this depends on values in the covariance matrix. This we will parameterize with a hyperparameter, a, that is the precision (1 / a) of the weight components. The cov matrix will have 1/a on its diagonal and zeros off-diagonal. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
weight_distribution <- function(mu, S) {
    structure(list(mu = mu,
                   S = S),
              class = "wdist")
}

prior_distribution <- function(a) {
    mu = c(0, 0)
    S = diag(1 / a, nrow = 2, ncol = 2)
    weight_distribution(mu, S)
}

# sample from the distribution with multivariate normal
sample_weights <- function(n, distribution) {
    MASS::mvrnorm(n = n,
                  mu = distribution$mu,
                  Sigma = distribution$S)
}

# sample from lines from the prior and plot them. We strongly believe it is flat and going through the origin
prior <- prior_distribution(1)
(w <- sample_weights(5, prior))

plot(c(-1, 1), c(-1, 1), type = "n", xlab = "", ylab = "")
plot_lines <- function(w) {
    for (i in 1:nrow(w)) {
        abline(a = w[i, 1], b = w[i, 2])
    }
}
plot_lines(w)
#+END_SRC

When we observe data in the form of matching X and Y values, we must update the w vector to reflect this, which means updating the distribution of the weights. 

If mu0 is the prior mean, and S0 the prior covariance matrix, then the posterior mean and cov matrix are computed thus: 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
S <- solve(S0 + b * t(X) %*% X)
mu <- S %*% (solve(S0) %*% mu0 + b * t(X) %*% y)
#+END_SRC 

In this case, b is the precision of the error terms and X captures the x values. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
fit_posterior <- function(x, y, b, prior) {
    mu0 <- prior$mu
    S0 <- prior$S

    X <- matrix(c(rep(1, length(x)), x), ncol = 2)
    S <- solve(S0 + b * t(X) %*% X)
    mu <- S %*% (solve(S0) %*% mu0 + b * t(X) %*% y)

    weight_distribution(mu = mu, S = S)
}

x <- rnorm(20)
y <- 0.2 + 1.3 * x + rnorm(20)

plot(x, y)
posterior <- fit_posterior(x, y, 1, prior)
w <- sample_weights(5, posterior)
plot_lines(w)

x <- rnorm(20000)
y <- 0.2 + 1.3 * x + rnorm(20000)

plot(x, y)
posterior <- fit_posterior(x, y, 1, prior)
w <- sample_weights(5, posterior)
plot_lines(w)
#+END_SRC

*** Model Matrices 

The X matrix we used when fitting the posterior is an example of a model matrix, or design matrix. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
x <- rnorm(5); y <- 1.2 + 2 * x + rnorm(5)

model.matrix(y ~ x)

d <- data.frame(x, y)
model.matrix(y ~ x, data = d)

# the formula decides how the model matrix is constructed. We can use y ~ x to remove the intercept
model.matrix(y ~ x - 1, data = d)

# or we could add terms
model.matrix(y ~ x + I(x**2), data = d)
#+END_SRC

The model matrix doesn't include the response variable y, but we can use the related model.frame function

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
model.frame(y ~ x + I(x**2), data = d)

# extract the response variable
model.response(model.frame(y ~ x + I(x**2), data = d))
#+END_SRC

With that machinery in place, we can generalize our distributions and model fitting to work with the general formula 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
# write a prior function
prior_distribution <- function(formula, a, data) {
    n <- ncol(model.matrix(formula, data = data))
    mu <- rep(0, n)
    S <- diag(1 / a, nrow = n, ncol = n)
    weight_distribution(mu, S)
}
#+END_SRC

The function for fitting the data changes less 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
fit_posterior <- function(formula, b, prior, data) {
    mu0 <- prior$mu
    S0 <- prior$S

    X <- model.matrix(formula, data = data)
    S <- solve(S0 + b * t(X) %*% X)
    mu <- S %*% (solve(S0) %*% mu0 + b * t(X) %*% y)

    weight_distribution(mu = mu, S = S)   
}

# now we can fit a line as before using a formula 
d <- {
    x <- rnorm(5)
    y <- 1.2 + 2 * x + rnorm(5)
    data.frame(x = x, y = y)
}

prior <- prior_distribution(y ~ x, 1, d)
(posterior <- fit_posterior(y ~ x, 1, prior, d))

# if we wished to fit a quadratic function, we can just provide a different formula
prior <- prior_distribution(y ~ x + I(x**2), 1, d)
(posterior <- fit_posterior(y ~ x + I(x**2), 1, prior, d))
#+END_SRC

*** Constructing Fitted Model Objects 

We want to wrap fitted models in a class so we can write a constructor for them. For fitted models, it is traditional to include the formula, data and the function call together with the fitted model 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
# constructor
blm <- function(formula, b, data, prior = NULL, a = NULL) {
    if (is.null(prior)) {
        if (is.null(a)) stop("Without a prior, you must provide a.")
        prior <- prior_distribution(formula, a, data)
    } else {
        if (inherits(prior, "blm")) {
            prior <- prior$prior
        }
    }

    if (!inherits(prior, "wdist")) stop("The provided prior does not have the expected type.")

    posterior <- fit_posterior(formula, b, prior, data)

    structure(list(formula = formula,
                   data = model.frame(formula, data),
                   dist = posterior,
                   call = match.call()),
              class = "blm")
}

# we can provide our out generic print function for blm 
print.blm <- function(x, ...) {
    print(x$call)
}

(model <- blm(y ~ x + I(x**2), a = 1, b = 1, data = d))
#+END_SRC

*** Coefficients and Confidence Intervals 

Once we have a fitted model, we might want to get the fitted values. For the bayesian linear regression model, the fitted values are whole distributions, but we can take the mean values as point estimates and return those

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
coef.blm <- function(object, ...) {
    t(object$dist$mu)
}

coef(model)

# get confidence intervals
confint.blm <- function(object, parm, level = 0.95, ...) {
    if (missing(parm)) parm <- rownames(object$dist$mu)

    means <- object$dist$mu[parm, ]
    sds <- sqrt(diag(object$dist$S)[parm])

    lower_q <- qnorm(p = (1 - level) / 2,
                     mean = means,
                     sd = sds)

    upper_q <- qnorm(p = 1 - (1 - level) / 2,
                     mean = means,
                     sd = sds)

    quantiles <- cbind(lower_q, upper_q)
    quantile_names <- paste(100 * c((1 - level)/2, 1 - (1 - level) / 2),
                            "%",
                            sep = "")

    colnames(quantiles) <- quantile_names
    quantiles
}

confint(model)
#+END_SRC

*** Predicting Response Variables 

When it comes to predicting response variables for new data, we need to do a bit more work in order to make up for the fact that we don't explicitly have the response variables in our new data's dataframe.

To remove the response variable from a formula, before we construct a model matrix, we need to use the function delete.response. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
predict.blm <- function(object, newdata, ...) {
    updated_terms <- delete.response(terms(object$formula))
    X <- model.matrix(updated_terms, data = newdata)

    predictions <- vector("numeric", length = nrow(X))
    for (i in seq_along(predictions)) {
        predictions[i] <- t(object$dist$mu) %*% X[i, ]
    }
    predictions
}

predict(model, d)
#+END_SRC

To check the model, we can plot the predicted values against the true response values. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
d <- {
    x <- rnorm(50)
    y <- 0.2 + 1.4 * x + rnorm(50)
    data.frame(x = x, y = y)
}

model <- blm(y ~ x, d, a = 1, b = 1)

plot(d$y,
     predict(model, d),
     xlab = "True Responses",
     ylab = "Predicted Responses")
#+END_SRC

Predicting values for the original data is so common that there is another generic function for this, called fitted. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
fitted.blm <- function(object, ...) {
    predict(object, newdata = object$data, ...)
}

plot(d$y, fitted(model),
     xlab = "True Responses",
     ylab = "Predicted Responses")
#+END_SRC

We can also do better than predicting point estimates. We have a distribution of weights, so the slope and intercept of a line aren't fixed. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
# update constructor
blm <- function(formula, b, data, prior = NULL, a = NULL) {
    if (is.null(prior)) {
        if (is.null(a)) stop("Without a prior, you must provide a.")
        prior <- prior_distribution(formula, a, data)
    } else {
        if (inherits(prior, "blm")) {
            prior <- prior$prior
        }
    }

    if (!inherits(prior, "wdist")) stop("The provided prior does not have the expected type.")

    posterior <- fit_posterior(formula, b, prior, data)

    structure(list(formula = formula,
                   data = model.frame(formula, data),
                   dist = posterior,
                   precision = b, # add precision
                   call = match.call()),
              class = "blm")
}

# extend our predict function
predict.blm <- function(object, newdata, intervals = FALSE, level = 0.95, ...) {
    updated_terms <- delete.response(terms(object$formula))
    X <- model.matrix(updated_terms, data = newdata)

    predictions <- vector("numeric", length = nrow(X))
    for (i in seq_along(predictions)) {
        predictions[i] <- t(object$dist$mu) %*% X[i, ]
    }

    if (!intervals) return(predictions)

    S <- object$dist$S
    b <- object$precision

    sds <- vector("numeric", length = nrow(X))
    for (i in seq_along(predictions)) {
        sds[i] <- sqrt(1 / b + t(X[i, ]) %*% S %*% X[i, ])
    }

    lower_q <- qnorm(p = (1 - level) / 2,
                     mean = predictions,
                     sd = sds)
    
    upper_q <- qnorm(p = 1 - (1 - level) / 2,
                     mean = predictions,
                     sd = sds)

    intervals <- cbind(lower_q, predictions, upper_q)
    colnames(intervals) <- c("lower", "mean", "upper")
    as.data.frame(intervals)
}
#+END_SRC

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
model <- blm(y ~ x, d, a = 1, b = 1)

predictions <- fitted(model, intervals = TRUE)

ggplot(cbind(data.frame(y = d$y), predictions),
       aes(x = y, y = mean)) +
    geom_point() +
    geom_errorbar(aes(ymin = lower, ymax = upper)) +
    geom_abline(slope = 1) +
    xlab("True Responses") + ylab("Predictions")
#+END_SRC

** Chapter 5 | Operator Overloading 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
modulus <- function(value, n) {
    result <- value %% n
    attr(result, "modulus") <- n
    class(result) <- c("modulus", class(value))
    result
}

# pretty printing results
print.modulus <- function(x, ...) {
    cat("Modulus", attr(x, "modulus"), "values:\n")
    # remove attributes to get plain numeric printing 
    x <- unclass(x)
    attributes(x) <- NULL
    NextMethod()
}

(x <- modulus(1:6, 3))
#+END_SRC

*** Defining Single Operators 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
# define what addition means for this type
`+.modulus` <- function(x, y) {
    # check types of operands and that the two operands are compatible
    nx <- attr(x, "modulus"); ny <- attr(y, "modulus")
    if (!is.null(nx) && !is.null(ny) && nx != ny) stop("Incompatible Types")
    n <- ifelse(!is.null(nx), nx, ny)
    x <- unclass(x); y <- unclass(y)
    modulus(x + y, n)
}

x + 1:6
1:6 + x

y <- modulus(rev(1:6), 3)
x + y
#+END_SRC

*** Group Operators 

Using generic functions, we can define all relevant operators for a user-defined type, but it is also possible to handle all operators in a single function, Ops. This function is called a "group generic method". This is like a default method.

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
Ops.modulus <- function(e1, e2) {
    nx <- attr(e1, "modulus")
    ny <- attr(e2, "modulus")
    if (!is.null(nx) && !is.null(ny) && nx != ny) stop("Incompatible Types")
    n <- ifelse(!is.null(nx), nx, ny)
    result <- unclass(NextMethod()) %% n
    modulus(result, n)
}
#+END_SRC

With this function, we get all the binary operators in one go

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
y <- modulus(rev(1:6), 3)

x - y
x * y
x == y
x == x
x != y
x != x
- x
#+END_SRC

*** Units Example 

In this section we define a class for associating physical units with values. This will allow us to check that units we manipulate are compatible. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
symbolic_unit <- function(numerator, denominator = "") {
    rm_empty <- function(exp) {
        non_empty <- function(x) x != ""
        sort(Filter(non_empty, exp))
    }
    numerator <- rm_empty(numerator)
    denominator <- rm_empty(denominator)
    structure(list(numerator = numerator,
                   denominator = denominator),
              class = "symbolic_unit")
}

# pretty printing
as.character.symbolic_unit <- function(x, ...) {
    format_terms <- function(terms, op) {
        if (length(terms) == 0) return("1")
        paste0(terms, collapse = op)
    }
    numerator <- format_terms(x$numerator, "*")
    denominator <- format_terms(x$denominator, "/")
    paste(numerator, "/", denominator)
}

print.symbolic_unit <- function(x, ...) {
    cat(as.character(x, ...), "\n")
}

(x <- symbolic_unit("m"))
(y <- symbolic_unit("m", "s"))
#+END_SRC

Comparing two symbolic units involves checking that the numerator and denominator are equal 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
`==.symbolic_unit` <- function(x, y) {
    if (!(inherits(x, "symbolic_unit") &&
          inherits(y, "symbolic_unit")))
        stop("Incompatible Types")
    return(identical(x$numerator, y$numerator) &&
           identical(x$denominator, y$denominator))
}

`!=.symbolic_unit` <- function(x, y) !(x == y)

x == y
x != y

`*.symbolic_unit` <- function(x, y) {
    symbolic_unit(c(x$numerator, y$numerator),
                  c(x$denominator, y$denominator))
}

`/.symbolic_unit` <- function(x, y) {
    symbolic_unit(c(x$numerator, y$denominator),
                  c(x$denominator, y$numerator))
}

x * y
x / y 
#+END_SRC

We now have everything in place to represent units. We just need to define the class for associating units with quantities. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
units <- function(value, numerator, denominator = "") {
    attr(value, "units") <- symbolic_unit(numerator, denominator)
    class(value) <- c("units", class(value))
    value
}

# pretty printing
print.units <- function(x, ...) {
    cat("Units: ", as.character(attr(x, "units")), "\n")
    # remove attributes to get plain numeric printing
    x <- unclass(x)
    attributes(x) <- NULL
    NextMethod()
}

(x <- units(1:6, "m", "s^2"))
#+END_SRC

We need to distinguish between operators where we require that the units match and those where we need to construct new units. The former are addition, subtraction, and comparisons; the latter and multiplication and division. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
Ops.units <- function(e1, e2) {
    su1 <- attr(e1, "units")
    su2 <- if (!missing(e2)) attr(e2, "units") else NULL

    if (.Generic %in% c("+", "-", "==", "!=", "<", "<=", ">=", ">")) {
        if (!is.null(su1) && !is.null(su2) && su1 != su2) stop("Incompatible Units")
        su <- ifelse(!is.null(su1), su1, su2)
        return(NextMethod())
    }

    if (.Generic == "*" || .Generic == "/") {
        if (is.null(su1)) su1 <- symbolic_unit("")
        if (is.null(su2)) su2 <- symbolic_unit("")
        su <- switch(.Generic,
                     "*" = su1 * su2,
                     "/" = su1 / su2)
        result <- NextMethod()
        attr(result, "units") <- su
        return(result)
    }

    # for the remaining ops we don't have a good way of treating the units so we strip them to numerics
    e1 <- unclass(e1); e2 <- unclass(e2)
    attributes(e1) <- attributes(e2) <- NULL
    NextMethod()
}

# now we can combine units with scalars
2 * x 
x + 2
x - 2

# we also get compatibility warnings
(y <- units(1:6, "m", "s"))
x + y

(z <- units(1:6, "m", "s^2"))
x + z
x - z

# mult and division are always permissible 
2 * x
x * y
x / y 
#+END_SRC

** Chapter 6 | S4 Classes 

The S4 system offers a more structured object oriented system. Here classes and class hierarchies are explicitly created. 

*** Defining S4 Classes 

To create a new class, we use the function setClass from the methods package. This takes arguments that specify which attributes the objects of the class should hold, what default values the attributes should have, how the class fits into a class hierarchy, and many other properties of the created class. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
library(methods)

# create an abstract stack class 
Stack <- setClass("Stack")

# create concrete class 
VectorStack <- setClass("VectorStack",
                        # list of attributes that objects of the class should have
                        slots = c(elements = "vector"),
                        # specify which superclasses the new class should have 
                        contains = "Stack")

# constructor
(vs <- VectorStack(elements = 1:4))

# access elements
vs@elements

# once a class is built with setClass you can create objects just using the name of the class
new("VectorStack", elements = 1:4)
#+END_SRC

*** Generic Functions 

In S4 we define generic functions explicitly using the setGeneric function. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
# define the interface of the stack abstract data structure
setGeneric("top", def = function(stack) standardGeneric("top"))
setGeneric("pop", def = function(stack) standardGeneric("pop"))
setGeneric("push", def = function(stack, element) standardGeneric("push"))
setGeneric("is_empty", def = function(stack) standardGeneric("is_empty"))
#+END_SRC

To provide implementations of generic functions, we use setMethod. When the generic function is called, the concrete implementation is chosen based on the type of the arguments in the function. This is typically called dynamic dispatch. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
setMethod("top", signature = "VectorStack",
          definition = function(stack) stack@elements[1])

setMethod("pop", signature = "VectorStack",
          definition = function(stack) stack@elements[-1])

setMethod("push", signature = "VectorStack",
          definition = function(stack, element) {
              VectorStack(elements = c(element, stack@elements))})

setMethod("is_empty", signature = "VectorStack",
          definition = function(stack) length(stack@elements) == 0)
#+END_SRC

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
# try it out 
(VectorStack() %>%
    push(1) %>%
    push(2) %>%
    push(3) -> stack)

while (!is_empty(stack)) stack <- pop(stack)
#+END_SRC

*** Slot Prototypes 

When you create an object without values for the slots, you get default values. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
NaturalNumber <- setClass("NaturalNumber",
                          slots = c(n = "integer"))

(n <- NaturalNumber())
#+END_SRC

If we want other default values, we can use the prototype argument to setClass. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
# state the default natural number is 1
NaturalNumber <- setClass("NaturalNumber",
                          slots = c(n = "integer"),
                          prototype = list(n = as.integer(1)))

(n <- NaturalNumber())

# we can still specify other values as args 
(n <- NaturalNumber(n = as.integer(2)))
#+END_SRC

*** Object Validity 

The type we give slots when we specify them puts type constraints on objects. 

We can put further restaints on objects via the validity argument to setClass. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
NaturalNumber <- setClass("NaturalNumber",
                          slots = c(n = "integer"),
                          prototype = list(n = as.integer(1)),
                          validity = function(object) object@n >= 0)

(n <- NaturalNumber(n = as.integer(-1)))

# validity test is only done on making objects
n@n <- as.integer(-1)
validObject(n)
#+END_SRC

*** Generic Functions and Class Hierarchies 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
A <- setClass("A", contains = "NULL")
B <- setClass("B", contains = "A")
C <- setClass("C", contains = "B")

x <- A(); y <- B(); z <- C()

# define a generic fn f and only implement it for class A
setGeneric("f", def = function(x) standardGeneric("f"))
setMethod("f", signature = "A",
          definition = function(x) print("A::f"))

list(x, y, z) %>% walk(f)
#+END_SRC

If we define another function, g, that we implement for both A and B, then calling it on x will call the A version. Calling it on y and z will invoke the B version since this is the most specialized form of the function for those two classes 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
setGeneric("g",
           def = function(x) standardGeneric("g"))
setMethod("g", signature = "A",
          definition = function(x) print("A::g"))
setMethod("g", signature = "B",
          definition = function(x) print("B::g"))

list(x, y, z) %>% walk(g)
#+END_SRC

The analogue of NextMethod in S4 is called callNextMethod and it works very similarly 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
setMethod("h", signature = "A",
          definition = function(x) print("A::h"))
setMethod("h", signature = "B",
          definition = function(x) {
              print("B::h")
              callNextMethod()
          })
setMethod("h", signature = "C",
          definition = function(x) {
              print("C::h")
              callNextMethod()
          })

list(x, y, z) %>% walk(h)
#+END_SRC

There is no .default version of methods, but we can use the setGeneric function to create one. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
d <- function(x) print("default::d")
setGeneric("d")
list(x, y, z) %>% walk(d)

# this also works when we specialize and use callNextMethod
setMethod("d", signature = "A",
          definition = function(x) {
              print("A::d")
              callNextMethod()
          })
setMethod("d", signature = "B",
          definition = function(x) {
              print("B::d")
              callNextMethod()
          })
setMethod("d", signature = "C",
          definition = function(x) {
              print("C::d")
              callNextMethod()
          })

list(x, y, z) %>% walk(d)
#+END_SRC

*** Requiring Methods 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
ListStack <- setClass("ListStack", contains = "stack")
requireMethods(functions = c("top", "pop", "push", "is_empty"),
               signature = "Stack")

pop(stack)
#+END_SRC

*** Constructors 

You can provide values for slots when you create objects by providing them as named arguments, but you can also get more control over object initialization through the method initialize. This works as a constructor, except that it doesn't create an object -- it sets attributes to leave it in a consistent state. If you define this function, it replaces the default constructor, and you are in charge of which arguments the constructor should take, how it should set slots, and whether it should call the constructor of its superclass. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
A <- setClass("A", slots = list(x = "numeric", y = "numeric"))
B <- setClass("B", contains = "A", slots = list(z = "numeric"))

setMethod("initialize",
          signature = "A",
          definition = function(.Object, x, y) {
              .Object@x <- x
              .Object@y <- y
              .Object
          })

setMethod("initialize",
          signature = "B",
          definition = function(.Object, z) {
              .Object <- callNextMethod(.Object, x = z, y = z)
              .Object@z <- z
              .Object
          })

(a <- A(x = 1:3, y = 4:6))
(b <- B(z = 6:9))
#+END_SRC

*** Dispatching on Type-Signatures 


